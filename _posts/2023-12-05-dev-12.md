---
layout: single
title:  "[데브코스] TIL-12"

categories: dev-course
tag: [데이터 분석, 데이터 분석가]
search: true
toc: true
toc_label: TIL ( Today I Learned )
author_profile: false
sidebar:
    nav: "docs"
---
12일차!  

# 다양한 JOINS
- JOIN: 두 개 이상의 테이블을 특정 key를 기준으로 결합하는 것
- 테이블을 따로 두는 이유: 변경 사항이 있을때 관리 용이, 데이터 중복 최소화

## inner join

```SQL
SELECT clicks.*, ordered
FROM clicks INNER JOIN orders 
ON clicks.user_name = orders.user_name
AND clicks.product_id = orders.products_id
AND clicks.date = orders.date
```

## left join

```SQL
SELECT clicks.*, ordered
FROM clicks LEFT JOIN orders 
ON clicks.user_name = orders.user_name
AND clicks.product_id = orders.products_id
AND clicks.date = orders.date
INNER JOIN products on clicks.product_id = products.product_id
WHERE products.category = '디지털'
AND odr_index is NULL
```

## right join

```SQL
SELECT orders.*, clk_index
FROM clicks RIGHT JOIN orders 
ON clicks.user_name = orders.user_name
AND clicks.product_id = orders.products_id
AND clicks.date = orders.date
```
## Full outer join
left와 right를 UNION으로 묶어준다.
모든 경우를 가져오기 때문에 NULL값들이 많이 존재할 수 있다.
```SQL
SELECT orders.*, clk_index
FROM clicks LEFT JOIN orders 
ON clicks.user_name = orders.user_name
AND clicks.product_id = orders.products_id
AND clicks.date = orders.date
UNION
SELECT orders.*, clk_index
FROM clicks RIGHT JOIN orders 
ON clicks.user_name = orders.user_name
AND clicks.product_id = orders.products_id
AND clicks.date = orders.date
```

## cross join
두 테이블 사이 가능한 모든 조합  
- 테이블간 집계를 진행 할 때 사용
```SQL
SELECT clicks.*, odr_index, orders.product_id as odr_product_id, orders.user_name as odr_user_name, orders.date as odr_date
FROM clicks CROSS JOIN orders
```
## Alias
```SQL
SELECT c.*, o.odr_index, p.name
FROM clicks c LEFT JOIN orders o
ON c.user_name = o.user_name
AND c.product_id = o.products_id
AND c.date = o.date
INNER JOIN products p 
on c.product_id = p.product_id
```
## Self join
```SQL
SELECT m1.*, m2.id as sub_id, m2.name as sub_name
FROM managers_v2 m1 INNER JOIN managers_v2 m2
ON m1.substitute = m2.id
```
## 필터링
join을 진행한 후 select와 where를 진행
    - 따라서 필터링 먼저 진행 후 join해야 속도가 빠르다
```SQL
SELECT c.*, o.odr_index, p.name
FROM clicks c LEFT JOIN orders o
ON c.user_name = o.user_name
AND c.product_id = o.products_id
AND c.date = o.date
INNER JOIN products p 
on c.product_id = p.product_id
WHERE p.category = '스포츠'
```
# UNION

# WITH

# Subquery